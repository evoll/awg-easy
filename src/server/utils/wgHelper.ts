import { parseCidr } from 'cidr-tools';
import { stringifyIp } from 'ip-bigint';
import type { ClientType } from '#db/repositories/client/types';
import type { InterfaceType } from '#db/repositories/interface/types';
import type { UserConfigType } from '#db/repositories/userConfig/types';
import type { HooksType } from '#db/repositories/hooks/types';

type Options = {
  enableIpv6?: boolean;
};

let wgExecutable: 'awg' | 'wg' = 'wg';

if (WG_ENV.EXPERIMENTAL_AWG) {
  if (WG_ENV.OVERRIDE_AUTO_AWG !== undefined) {
    wgExecutable = WG_ENV.OVERRIDE_AUTO_AWG;
  } else {
    // Try to detect amneziawg kernel module availability
    wgExecutable = await exec('modinfo amneziawg')
      .then(() => 'awg' as const)
      .catch(() => 'wg' as const);
  }
}

export const isUsingAwg = () => wgExecutable === 'awg';

export const wg = {
  generateServerPeer: (
    client: Omit<ClientType, 'createdAt' | 'updatedAt'>,
    options: Options = {},
  ) => {
    const { enableIpv6 = true } = options;

    const allowedIps = [
      `${client.ipv4Address}/32`,
      ...(enableIpv6 ? [`${client.ipv6Address}/128`] : []),
      ...(client.serverAllowedIps ?? []),
    ];

    const extraLines: string[] = [];
    if (client.serverEndpoint) {
      extraLines.push(`Endpoint = ${client.serverEndpoint}`);
    }

    return `# Client: ${client.name} (${client.id})
[Peer]
PublicKey = ${client.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${allowedIps.join(', ')}${
      extraLines.length ? `\n${extraLines.join('\n')}` : ''
    }`;
  },

  generateServerInterface: (
    wgInterface: InterfaceType,
    hooks: HooksType,
    options: Options = {},
  ) => {
    const { enableIpv6 = true } = options;

    const cidr4 = parseCidr(wgInterface.ipv4Cidr);
    const cidr6 = parseCidr(wgInterface.ipv6Cidr);
    const ipv4Addr = stringifyIp({ number: cidr4.start + 1n, version: 4 });
    const ipv6Addr = stringifyIp({ number: cidr6.start + 1n, version: 6 });

    const address =
      `${ipv4Addr}/${cidr4.prefix}` + (enableIpv6 ? `, ${ipv6Addr}/${cidr6.prefix}` : '');

    // Add AmneziaWG obfuscation parameters if using awg
    const amneziaParams =
      wgExecutable === 'awg'
        ? `
Jc = ${wgInterface.jc}
Jmin = ${wgInterface.jmin}
Jmax = ${wgInterface.jmax}
S1 = ${wgInterface.s1}
S2 = ${wgInterface.s2}${wgInterface.s3 > 0 ? `
S3 = ${wgInterface.s3}` : ''}${wgInterface.s4 > 0 ? `
S4 = ${wgInterface.s4}` : ''}
H1 = ${wgInterface.h1}
H2 = ${wgInterface.h2}
H3 = ${wgInterface.h3}
H4 = ${wgInterface.h4}${wgInterface.i1 ? `
I1 = ${wgInterface.i1}` : ''}${wgInterface.i2 ? `
I2 = ${wgInterface.i2}` : ''}${wgInterface.i3 ? `
I3 = ${wgInterface.i3}` : ''}${wgInterface.i4 ? `
I4 = ${wgInterface.i4}` : ''}${wgInterface.i5 ? `
I5 = ${wgInterface.i5}` : ''}${wgInterface.j1 ? `
J1 = ${wgInterface.j1}` : ''}${wgInterface.j2 ? `
J2 = ${wgInterface.j2}` : ''}${wgInterface.j3 ? `
J3 = ${wgInterface.j3}` : ''}${wgInterface.itime > 0 ? `
Itime = ${wgInterface.itime}` : ''}`
        : '';

    return `# Note: Do not edit this file directly.
# Your changes will be overwritten!

# Server
[Interface]
PrivateKey = ${wgInterface.privateKey}
Address = ${address}
ListenPort = ${wgInterface.port}
MTU = ${wgInterface.mtu}
PreUp = ${iptablesTemplate(hooks.preUp, wgInterface)}
PostUp = ${iptablesTemplate(hooks.postUp, wgInterface)}
PreDown = ${iptablesTemplate(hooks.preDown, wgInterface)}
PostDown = ${iptablesTemplate(hooks.postDown, wgInterface)}${amneziaParams}`;
  },

  generateClientConfig: (
    wgInterface: InterfaceType,
    userConfig: UserConfigType,
    client: ClientType,
    options: Options = {},
  ) => {
    const { enableIpv6 = true } = options;

    const address =
      `${client.ipv4Address}/32` + (enableIpv6 ? `, ${client.ipv6Address}/128` : '');

    const hookLines = [
      client.preUp ? `PreUp = ${client.preUp}` : null,
      client.postUp ? `PostUp = ${client.postUp}` : null,
      client.preDown ? `PreDown = ${client.preDown}` : null,
      client.postDown ? `PostDown = ${client.postDown}` : null,
    ];

    const dnsServers = client.dns ?? userConfig.defaultDns;
    const dnsLine = dnsServers.length > 0 ? `DNS = ${dnsServers.join(', ')}` : null;

    const extraLines = [dnsLine, ...hookLines].filter((v) => v !== null) as string[];

    // Add AmneziaWG obfuscation parameters to client config if using awg
    const clientAmneziaParams =
      wgExecutable === 'awg'
        ? `
Jc = ${wgInterface.jc}
Jmin = ${wgInterface.jmin}
Jmax = ${wgInterface.jmax}
S1 = ${wgInterface.s1}
S2 = ${wgInterface.s2}${wgInterface.s3 > 0 ? `
S3 = ${wgInterface.s3}` : ''}${wgInterface.s4 > 0 ? `
S4 = ${wgInterface.s4}` : ''}
H1 = ${wgInterface.h1}
H2 = ${wgInterface.h2}
H3 = ${wgInterface.h3}
H4 = ${wgInterface.h4}${wgInterface.i1 ? `
I1 = ${wgInterface.i1}` : ''}${wgInterface.i2 ? `
I2 = ${wgInterface.i2}` : ''}${wgInterface.i3 ? `
I3 = ${wgInterface.i3}` : ''}${wgInterface.i4 ? `
I4 = ${wgInterface.i4}` : ''}${wgInterface.i5 ? `
I5 = ${wgInterface.i5}` : ''}${wgInterface.j1 ? `
J1 = ${wgInterface.j1}` : ''}${wgInterface.j2 ? `
J2 = ${wgInterface.j2}` : ''}${wgInterface.j3 ? `
J3 = ${wgInterface.j3}` : ''}${wgInterface.itime > 0 ? `
Itime = ${wgInterface.itime}` : ''}
`
        : '';

    return `[Interface]
PrivateKey = ${client.privateKey}
Address = ${address}
MTU = ${client.mtu}
${extraLines.length ? `${extraLines.join('\n')}\n` : ''}${clientAmneziaParams}
[Peer]
PublicKey = ${wgInterface.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${(client.allowedIps ?? userConfig.defaultAllowedIps).join(', ')}
PersistentKeepalive = ${client.persistentKeepalive}
Endpoint = ${userConfig.host}:${userConfig.port}`;
  },

  generatePrivateKey: () => {
    return exec(`${wgExecutable} genkey`);
  },

  getPublicKey: (privateKey: string) => {
    return exec(`echo ${privateKey} | ${wgExecutable} pubkey`, {
      log: `echo ***hidden*** | ${wgExecutable} pubkey`,
    });
  },

  generatePreSharedKey: () => {
    return exec(`${wgExecutable} genpsk`);
  },

  up: (infName: string) => {
    return exec(`${wgExecutable}-quick up ${infName}`);
  },

  down: (infName: string) => {
    return exec(`${wgExecutable}-quick down ${infName}`);
  },

  restart: (infName: string) => {
    return exec(
      `${wgExecutable}-quick down ${infName}; ${wgExecutable}-quick up ${infName}`,
    );
  },

  sync: (infName: string) => {
    return exec(
      `${wgExecutable} syncconf ${infName} <(${wgExecutable}-quick strip ${infName})`,
    );
  },

  dump: async (infName: string) => {
    const rawDump = await exec(`${wgExecutable} show ${infName} dump`, {
      log: false,
    });

    type wgDumpLine = [
      string,
      string,
      string,
      string,
      string,
      string,
      string,
      string,
    ];

    return rawDump
      .trim()
      .split('\n')
      .slice(1)
      .map((line) => {
        const splitLines = line.split('\t');
        const [
          publicKey,
          preSharedKey,
          endpoint,
          allowedIps,
          latestHandshakeAt,
          transferRx,
          transferTx,
          persistentKeepalive,
        ] = splitLines as wgDumpLine;

        return {
          publicKey,
          preSharedKey,
          endpoint: endpoint === '(none)' ? null : endpoint,
          allowedIps,
          latestHandshakeAt:
            latestHandshakeAt === '0'
              ? null
              : new Date(Number.parseInt(`${latestHandshakeAt}000`)),
          transferRx: Number.parseInt(transferRx),
          transferTx: Number.parseInt(transferTx),
          persistentKeepalive: persistentKeepalive,
        };
      });
  },
};
